# Intelligent System for Automation of Security Audits (SIAAS)
# Agent - Metasploit module (ENHANCED VERSION)
# By JoÃ£o Pedro Seara, 2022-2024
# Enhanced for comprehensive web app and service scanning

import siaas_aux
import os
import sys
import logging
import time
import subprocess
import concurrent.futures
import json
import re

logger = logging.getLogger(__name__)


def parse_raw_output_from_metasploit(raw_data=""):
    """
    Enhanced parser for Metasploit output into SIAAS format
    Returns a tuple with the findings dict, total number of vulnerabilities, and total number of exploits
    """
    out_dict = {}
    total_vulns = 0
    total_exploits = 0

    if not raw_data:
        return (out_dict, total_vulns, total_exploits)

    lines = raw_data.split('\n')
    current_module = "unknown"
    module_findings = []
    
    for line in lines:
        line = line.strip()
        
        # Module start
        if line.startswith('[+]') and ('module' in line.lower() or 'auxiliary' in line.lower()):
            current_module = line.replace('[+]', '').strip()
            out_dict[current_module] = {}
            module_findings = []
            continue
            
        # Results section
        elif 'Results' in line and '========' in line:
            continue
            
        # Vulnerability/Exploit findings
        elif '[+]' in line or '[*]' in line:
            finding_type = 'info'
            if '[+]' in line:
                finding_type = 'vulnerability'
                if 'exploit' in line.lower() or 'vulnerable' in line.lower():
                    finding_type = 'exploit'
            
            finding_info = line.replace('[+]', '').replace('[*]', '').strip()
            
            # Determine severity based on content
            severity = 3.0  # Low by default
            confidence = "low"
            
            if finding_type == 'exploit':
                severity = 9.0
                confidence = "high"
                total_exploits += 1
                total_vulns += 1
            elif finding_type == 'vulnerability':
                severity = 6.0
                confidence = "medium"
                total_vulns += 1
            
            # Extract more details if available
            details_match = re.search(r'(https?://[^\s]+|[A-Z]+-\d+|CVE-\d+-\d+)', line, re.IGNORECASE)
            reference = details_match.group(1) if details_match else ""
            
            vuln_id = f"msf_{hash(finding_info) % 1000000:06d}"
            
            if current_module not in out_dict:
                out_dict[current_module] = {}
            
            out_dict[current_module][vuln_id] = {
                'type': finding_type.capitalize(),
                'name': finding_info[:100],
                'severity': severity,
                'confidence': confidence,
                'description': f'{finding_type} detected by {current_module}',
                'source': 'Metasploit Framework',
                'reference': reference,
                'raw_output': finding_info
            }
            
            module_findings.append(vuln_id)
    
    return (out_dict, total_vulns, total_exploits)


def get_recommended_modules_for_service(service, port, product=""):
    """
    Returns list of recommended Metasploit modules for a given service
    """
    modules = []
    
    service_lower = service.lower()
    product_lower = product.lower()
    
    # HTTP/HTTPS Services
    if 'http' in service_lower or port in ['80', '443', '8080', '8443', '3000', '8000']:
        modules.extend([
            ("auxiliary", "scanner/http/http_version", {"rport": port, "timeout": 120}),
            ("auxiliary", "scanner/http/robots_txt", {"rport": port, "timeout": 120}),
            ("auxiliary", "scanner/http/dir_scanner", {"rport": port, "timeout": 180}),
            ("auxiliary", "scanner/http/http_header", {"rport": port, "timeout": 120}),
            ("auxiliary", "scanner/http/backup_file", {"rport": port, "timeout": 120}),
            ("auxiliary", "scanner/http/options", {"rport": port, "timeout": 120}),
            ("auxiliary", "scanner/http/http_methods", {"rport": port, "timeout": 120}),
            ("auxiliary", "scanner/http/trace_axd", {"rport": port, "timeout": 120}),
        ])
        
        # CMS Detection
        modules.append(("auxiliary", "scanner/http/cms_version", {"rport": port, "timeout": 150}))
        
        # Basic vulnerability scanners
        modules.append(("auxiliary", "scanner/http/apache_userdir_enum", {"rport": port, "timeout": 120}))
        modules.append(("auxiliary", "scanner/http/tomcat_enum", {"rport": port, "timeout": 120}))
        
        # Add more aggressive scans if in safe mode
        try:
            safe_mode = siaas_aux.get_config_from_configs_db(config_name="metasploit_safe_mode")
            if safe_mode != "true":
                modules.append(("auxiliary", "scanner/http/http_login", {"rport": port, "timeout": 180}))
                modules.append(("auxiliary", "scanner/http/wordpress_login_enum", {"rport": port, "timeout": 180}))
        except:
            pass
    
    # SSH Services
    elif 'ssh' in service_lower:
        modules.extend([
            ("auxiliary", "scanner/ssh/ssh_version", {"rport": port, "timeout": 120}),
            ("auxiliary", "scanner/ssh/ssh_enumusers", {"rport": port, "timeout": 180, "USER_FILE": "/usr/share/wordlists/metasploit/default_users_for_services_unhash.txt"}),
        ])
    
    # SMB Services
    elif 'smb' in service_lower or 'microsoft-ds' in service_lower or 'netbios' in service_lower:
        modules.extend([
            ("auxiliary", "scanner/smb/smb_version", {"rport": port, "timeout": 120}),
            ("auxiliary", "scanner/smb/smb_enumshares", {"rport": port, "timeout": 180}),
            ("auxiliary", "scanner/smb/smb_enumusers", {"rport": port, "timeout": 180}),
        ])
    
    # FTP Services
    elif 'ftp' in service_lower:
        modules.extend([
            ("auxiliary", "scanner/ftp/ftp_version", {"rport": port, "timeout": 120}),
            ("auxiliary", "scanner/ftp/anonymous", {"rport": port, "timeout": 120}),
            ("auxiliary", "scanner/ftp/ftp_login", {"rport": port, "timeout": 180}),
        ])
    
    # MySQL Services
    elif 'mysql' in service_lower:
        modules.extend([
            ("auxiliary", "scanner/mysql/mysql_version", {"rport": port, "timeout": 120}),
            ("auxiliary", "scanner/mysql/mysql_login", {"rport": port, "timeout": 180}),
        ])
    
    # PostgreSQL Services
    elif 'postgresql' in service_lower or 'postgres' in service_lower:
        modules.extend([
            ("auxiliary", "scanner/postgres/postgres_version", {"rport": port, "timeout": 120}),
            ("auxiliary", "scanner/postgres/postgres_login", {"rport": port, "timeout": 180}),
        ])
    
    # MongoDB Services
    elif 'mongodb' in service_lower:
        modules.extend([
            ("auxiliary", "scanner/mongodb/mongodb_login", {"rport": port, "timeout": 180}),
        ])
    
    # RDP Services
    elif 'rdp' in service_lower or 'ms-wbt-server' in service_lower:
        modules.extend([
            ("auxiliary", "scanner/rdp/rdp_scanner", {"rport": port, "timeout": 120}),
        ])
    
    # VNC Services
    elif 'vnc' in service_lower:
        modules.extend([
            ("auxiliary", "scanner/vnc/vnc_none_auth", {"rport": port, "timeout": 120}),
        ])
    
    # Redis Services
    elif 'redis' in service_lower:
        modules.extend([
            ("auxiliary", "scanner/redis/redis_login", {"rport": port, "timeout": 180}),
        ])
    
    # Telnet Services
    elif 'telnet' in service_lower:
        modules.extend([
            ("auxiliary", "scanner/telnet/telnet_version", {"rport": port, "timeout": 120}),
            ("auxiliary", "scanner/telnet/telnet_login", {"rport": port, "timeout": 180}),
        ])
    
    # SNMP Services
    elif 'snmp' in service_lower:
        modules.extend([
            ("auxiliary", "scanner/snmp/snmp_login", {"rport": port, "timeout": 180}),
            ("auxiliary", "scanner/snmp/snmp_enum", {"rport": port, "timeout": 180}),
        ])
    
    # Default for any service
    else:
        modules.append(("auxiliary", "scanner/portscan/tcp", {"rport": port, "PORTS": port, "timeout": 60}))
    
    # Add service-specific exploit checks based on product version
    if product_lower:
        # Apache specific
        if 'apache' in product_lower and 'http' in service_lower:
            modules.append(("auxiliary", "scanner/http/apache_userdir_enum", {"rport": port, "timeout": 120}))
        
        # IIS specific
        elif 'iis' in product_lower or 'microsoft' in product_lower:
            modules.append(("auxiliary", "scanner/http/iis_internal_ip", {"rport": port, "timeout": 120}))
        
        # WordPress detection
        elif 'wordpress' in product_lower:
            modules.extend([
                ("auxiliary", "scanner/http/wordpress_scanner", {"rport": port, "timeout": 180}),
                ("auxiliary", "scanner/http/wordpress_login_enum", {"rport": port, "timeout": 180}),
            ])
        
        # Joomla detection
        elif 'joomla' in product_lower:
            modules.append(("auxiliary", "scanner/http/joomla_pages", {"rport": port, "timeout": 180}))
    
    return modules


def scan_with_metasploit(target, module_type="auxiliary", module_name="scanner/portscan/tcp", options=None):
    """
    Enhanced scan using a specific Metasploit module
    Returns tuple with findings dict, scan status, vulnerabilities count, exploits count
    """
    logger.info(f"Metasploit scanning {target} with {module_type}/{module_name}")
    
    scan_results_dict = {}
    total_vulns = 0
    total_exploits = 0
    
    if options is None:
        options = {}
    
    try:
        # Create resource file with proper formatting
        import tempfile
        with tempfile.NamedTemporaryFile(mode='w', suffix='.rc', delete=False) as rc_file:
            rc_content = f"""use {module_type}/{module_name}
set RHOSTS {target}
"""
            
            # Set RPORT if specified
            if 'rport' in options:
                rc_content += f"set RPORT {options['rport']}\n"
            
            # Set optional parameters
            for key, value in options.items():
                if key not in ['rhosts', 'rport', 'timeout']:
                    rc_content += f"set {key} {value}\n"
            
            # Add show options and run
            rc_content += "show options\n"
            rc_content += "run\n"
            rc_content += "exit\n"
            
            rc_file.write(rc_content)
            rc_file_path = rc_file.name
        
        # Run Metasploit with timeout
        timeout = int(options.get('timeout', 300))
        cmd = ["msfconsole", "-q", "-r", rc_file_path]
        
        # Add environment for better output
        env = os.environ.copy()
        env['TERM'] = 'xterm'
        
        logger.debug(f"Executing: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout, env=env)
        
        # Clean up
        os.unlink(rc_file_path)
        
        if result.returncode == 0:
            # Parse results
            module_results, n_vulns, n_exploits = parse_raw_output_from_metasploit(result.stdout)
            
            if module_results:
                scan_results_dict[f"{module_type}_{module_name.replace('/', '_')}"] = module_results
                total_vulns += n_vulns
                total_exploits += n_exploits
                
                logger.info(f"Metasploit module {module_name} completed: {n_vulns} vulnerabilities, {n_exploits} exploits")
            else:
                logger.debug(f"Metasploit module {module_name} found no vulnerabilities")
        else:
            logger.error(f"Metasploit module failed with return code {result.returncode}: {result.stderr[:200]}")
    
    except subprocess.TimeoutExpired:
        logger.warning(f"Metasploit module {module_name} timeout for {target}")
    except FileNotFoundError:
        logger.error(f"Metasploit not found. Is it installed?")
    except Exception as e:
        logger.error(f"Metasploit scan error for {module_name}: {e}")
    
    return (scan_results_dict, total_vulns, total_exploits)


def run_web_application_scan(target, port="80"):
    """
    Specialized web application scanning function
    """
    logger.info(f"Starting comprehensive web application scan for {target}:{port}")
    
    web_results = {}
    total_vulns = 0
    total_exploits = 0
    
    # Common web scanners
    web_modules = [
        ("auxiliary", "scanner/http/webdav_scanner", {"rport": port, "timeout": 120}),
        ("auxiliary", "scanner/http/http_put", {"rport": port, "timeout": 120}),
        ("auxiliary", "scanner/http/trace_axd", {"rport": port, "timeout": 120}),
        ("auxiliary", "scanner/http/apache_userdir_enum", {"rport": port, "timeout": 120}),
        ("auxiliary", "scanner/http/iis_internal_ip", {"rport": port, "timeout": 120}),
        ("auxiliary", "scanner/http/ssl_version", {"rport": port, "timeout": 120}),
        ("auxiliary", "scanner/http/hp_imc_mobileflexdisk_rce", {"rport": port, "timeout": 120}),
    ]
    
    # Run each module
    for module_type, module_name, options in web_modules:
        try:
            results, n_vulns, n_exploits = scan_with_metasploit(
                target, module_type, module_name, options
            )
            
            if results:
                web_results.update(results)
                total_vulns += n_vulns
                total_exploits += n_exploits
        except Exception as e:
            logger.error(f"Web module {module_name} failed: {e}")
    
    return (web_results, total_vulns, total_exploits)


def get_target_information(target):
    """
    Enhanced target information gathering
    """
    logger.info(f"Getting enhanced target information for {target}")
    
    sysinfo_dict = {}
    scanned_ports = {}
    
    try:
        # Try to get info from portscanner database
        portscanner_db = siaas_aux.read_from_local_file(
            os.path.join(sys.path[0], 'var/portscanner.db')
        )
        
        if target in portscanner_db:
            target_data = portscanner_db[target]
            sysinfo_dict = target_data.get('system_info', {})
            
            # Enhanced port information
            ports = target_data.get('scanned_ports', {})
            for port, info in ports.items():
                port_num = port.split('/')[0]
                scanned_ports[port] = {
                    'service': info.get('service', 'unknown'),
                    'state': info.get('state', 'unknown'),
                    'product': info.get('product', ''),
                    'version': info.get('version', ''),
                    'extrainfo': info.get('extrainfo', ''),
                    'cpe': info.get('cpe', '')
                }
        else:
            # Enhanced nmap scan
            import nmap3
            nmap = nmap3.NmapScanTechniques()
            
            # More comprehensive scan
            result = nmap.nmap_tcp_scan(target, args="-sV -T4 -p 80,443,8080,22,21,25,53,110,143,445,3389")
            
            for host, data in result.items():
                if host == 'runtime' or host == 'stats':
                    continue
                    
                sysinfo_dict = {
                    'scanned_ip': host,
                    'hostname': data.get('hostname', [{}])[0].get('name', ''),
                    'status': data.get('state', {}).get('state', 'unknown')
                }
                
                if 'ports' in data:
                    for port_info in data['ports']:
                        if 'portid' in port_info:
                            port_id = f"{port_info['portid']}/{port_info.get('protocol', 'tcp')}"
                            scanned_ports[port_id] = {
                                'service': port_info.get('service', {}).get('name', 'unknown'),
                                'state': port_info.get('state', 'unknown'),
                                'product': port_info.get('service', {}).get('product', ''),
                                'version': port_info.get('service', {}).get('version', ''),
                                'extrainfo': port_info.get('service', {}).get('extrainfo', ''),
                                'cpe': port_info.get('service', {}).get('cpe', '')
                            }
                break
    
    except ImportError:
        logger.warning("nmap3 not available, using basic port info")
        # Basic fallback
        sysinfo_dict = {'scanned_ip': target, 'status': 'unknown'}
        
        # Common ports to check
        common_ports = ['80/tcp', '443/tcp', '22/tcp', '21/tcp', '25/tcp', '3389/tcp']
        for port in common_ports:
            scanned_ports[port] = {'service': 'unknown', 'state': 'unknown', 'product': ''}
    
    except Exception as e:
        logger.error(f"Error getting target information: {e}")
        sysinfo_dict = {'error': str(e)}
    
    return (sysinfo_dict, scanned_ports)


def main(target="127.0.0.1"):
    """
    Main Metasploit scanner logic - ENHANCED VERSION
    """
    logger.info(f"Starting enhanced Metasploit scan for {target}")
    
    start_time = time.time()
    
    # Structure remains compatible
    target_info = {}
    target_info["system_info"] = {}
    target_info["scanned_ports"] = {}
    
    # Get target information
    system_info_output = get_target_information(target)
    target_info["system_info"] = system_info_output[0]
    scanned_ports = system_info_output[1]
    
    total_ports = len(scanned_ports)
    total_vulns = 0
    total_exploits = 0
    
    # Run Metasploit modules based on detected services
    target_info["scanned_ports"] = {}
    
    logger.info(f"Found {total_ports} open ports on {target}")
    
    for port, port_info in scanned_ports.items():
        port_num = port.split('/')[0]
        service = port_info.get('service', '').lower()
        product = port_info.get('product', '').lower()
        
        target_info["scanned_ports"][port] = port_info
        target_info["scanned_ports"][port]["scan_results"] = {}
        
        logger.info(f"Scanning port {port} ({service})")
        
        # Get recommended modules for this service
        recommended_modules = get_recommended_modules_for_service(service, port_num, product)
        
        port_vulns = 0
        port_exploits = 0
        port_results = {}
        
        # Run each recommended module
        for module_type, module_name, options in recommended_modules:
            try:
                # Limit concurrent modules per port
                module_results, n_vulns, n_exploits = scan_with_metasploit(
                    target, module_type, module_name, options
                )
                
                if module_results:
                    port_results.update(module_results)
                    port_vulns += n_vulns
                    port_exploits += n_exploits
                    
                    # Brief pause between modules
                    time.sleep(2)
                    
            except Exception as e:
                logger.error(f"Module {module_name} failed for port {port}: {e}")
        
        # Special web application scan for HTTP/HTTPS
        if 'http' in service and int(port_num) in [80, 443, 8080, 8443, 3000, 8000]:
            try:
                web_results, web_vulns, web_exploits = run_web_application_scan(target, port_num)
                if web_results:
                    port_results.update(web_results)
                    port_vulns += web_vulns
                    port_exploits += web_exploits
            except Exception as e:
                logger.error(f"Web application scan failed for port {port}: {e}")
        
        target_info["scanned_ports"][port]["scan_results"] = port_results
        total_vulns += port_vulns
        total_exploits += port_exploits
        
        logger.info(f"Port {port} scan complete: {port_vulns} vulnerabilities, {port_exploits} exploits")
    
    # Additional global scans (not port-specific)
    try:
        logger.info("Running global vulnerability scans...")
        
        global_modules = [
            ("auxiliary", "scanner/discovery/udp_sweep", {"timeout": 180}),
            ("auxiliary", "scanner/smb/smb_ms17_010", {"timeout": 180}),
            ("auxiliary", "scanner/http/jenkins_enum", {"rport": "8080", "timeout": 120}),
        ]
        
        global_results = {}
        for module_type, module_name, options in global_modules:
            try:
                module_results, n_vulns, n_exploits = scan_with_metasploit(target, module_type, module_name, options)
                if module_results:
                    global_results.update(module_results)
                    total_vulns += n_vulns
                    total_exploits += n_exploits
            except Exception as e:
                logger.error(f"Global module {module_name} failed: {e}")
        
        if global_results:
            target_info["global_scans"] = global_results
    
    except Exception as e:
        logger.error(f"Global scans failed: {e}")
    
    elapsed_time_sec = int(time.time() - start_time)
    
    logger.info(f"Enhanced Metasploit scan ended for {target}: {total_vulns} vulnerabilities ({total_exploits} exploits) across {total_ports} ports. Time: {elapsed_time_sec}s")
    
    # Statistics
    target_info["stats"] = {}
    target_info["stats"]["num_scanned_ports"] = total_ports
    target_info["stats"]["total_num_vulnerabilities"] = total_vulns
    target_info["stats"]["total_num_exploits"] = total_exploits
    target_info["stats"]["time_taken_sec"] = elapsed_time_sec
    target_info["last_check"] = siaas_aux.get_now_utc_str()
    
    # Summary of findings
    if total_vulns > 0:
        target_info["summary"] = {
            "critical_findings": total_exploits,
            "high_risk_findings": sum(1 for port in target_info["scanned_ports"].values() 
                                    for scan in port.get("scan_results", {}).values() 
                                    for finding in scan.values() 
                                    if isinstance(finding, dict) and finding.get('severity', 0) >= 7.0),
            "recommendations": [
                "Review all identified vulnerabilities",
                "Prioritize exploitable findings",
                "Update/configure services based on findings"
            ]
        }
    
    return (target, target_info)


def loop():
    """
    Enhanced Metasploit module loop
    """
    # Initializing the metasploit local DB
    os.makedirs(os.path.join(sys.path[0], 'var'), exist_ok=True)
    siaas_aux.write_to_local_file(os.path.join(
        sys.path[0], 'var/metasploit.db'), {})
    os.chmod(os.path.join(sys.path[0], 'var/metasploit.db'), os.stat(
        os.path.join(sys.path[0], 'var/metasploit.db')).st_mode & ~0o007)
    
    while True:
        
        metasploit_dict = {}
        scan_results_all = {}
        all_targets_to_scan = []
        
        logger.debug("Enhanced Metasploit loop running ...")
        
        # Check if metasploit scanning is enabled
        disable_metasploit = siaas_aux.get_config_from_configs_db(
            config_name="disable_metasploit", convert_to_string=True)
        if siaas_aux.validate_bool_string(disable_metasploit):
            logger.warning("Metasploit scanner is disabled as per configuration! Not running.")
            time.sleep(60)
            continue
        
        # Get safe mode configuration
        try:
            safe_mode = siaas_aux.get_config_from_configs_db(
                config_name="metasploit_safe_mode", convert_to_string=True)
            if safe_mode == "true":
                logger.info("Metasploit running in SAFE MODE (limited intrusive scans)")
        except:
            pass
        
        # Get targets from neighborhood
        neighborhood = siaas_aux.read_from_local_file(
            os.path.join(sys.path[0], 'var/neighborhood.db'))
        
        if not neighborhood or len(neighborhood) == 0:
            logger.warning("Couldn't read neighborhood data. Trying again ...")
            time.sleep(60)
            continue
        
        # Select targets - limit based on configuration
        try:
            max_targets = int(siaas_aux.get_config_from_configs_db(
                config_name="metasploit_max_targets_per_cycle"))
        except:
            max_targets = 2  # Default to 2 for safety
        
        for neighbor in list(neighborhood.keys())[:max_targets]:
            if neighbor and not neighbor.startswith('#'):
                all_targets_to_scan.append(neighbor)
        
        if not all_targets_to_scan:
            logger.warning("No valid targets found. Trying again ...")
            time.sleep(60)
            continue
        
        logger.info(f"Selected {len(all_targets_to_scan)} targets for Metasploit scanning")
        
        # Parallel scanning with thread limit
        try:
            max_workers = int(siaas_aux.get_config_from_configs_db(
                config_name="metasploit_max_parallel_workers"))
            if max_workers < 1:
                raise ValueError("Max workers can't be less than 1.")
            logger.debug(f"Using {max_workers} parallel workers for Metasploit")
        except:
            max_workers = 1  # Default to 1 for Metasploit (heavy)
            logger.debug("Using 1 parallel worker for Metasploit by default")
        
        # ThreadPoolExecutor
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = []
            for target in all_targets_to_scan:
                futures.append(executor.submit(main, target=target))
            
            for future in concurrent.futures.as_completed(futures):
                try:
                    result = future.result(timeout=3600)  # 1 hour timeout per target
                    scan_results_all[result[0]] = result[1]
                    
                    # Log summary
                    stats = result[1].get('stats', {})
                    logger.info(f"Scan completed for {result[0]}: {stats.get('total_num_vulnerabilities', 0)} vulnerabilities found")
                    
                except concurrent.futures.TimeoutError:
                    logger.error(f"Metasploit scan for target timed out after 1 hour")
                except Exception as e:
                    logger.error(f"Metasploit scan failed: {e}")
        
        # Create metasploit dict with sorted results
        metasploit_dict = siaas_aux.sort_ip_dict(scan_results_all)
        
        # Writing in local database
        siaas_aux.write_to_local_file(os.path.join(
            sys.path[0], 'var/metasploit.db'), metasploit_dict)
        
        # Export summary report
        export_summary_report(metasploit_dict)
        
        # Sleep before next loop
        try:
            sleep_time = int(siaas_aux.get_config_from_configs_db(
                config_name="metasploit_loop_interval_sec"))
            logger.info(f"Sleeping for {sleep_time} seconds before next loop ...")
            time.sleep(sleep_time)
        except:
            logger.info("Interval not configured. Sleeping for 6 hours by default ...")
            time.sleep(21600)  # 6 hours


def export_summary_report(metasploit_dict):
    """
    Export a summary report of findings
    """
    try:
        report_path = os.path.join(sys.path[0], 'var/metasploit_report.json')
        
        summary = {
            "generated": siaas_aux.get_now_utc_str(),
            "total_targets": len(metasploit_dict),
            "targets": {}
        }
        
        for target, data in metasploit_dict.items():
            stats = data.get('stats', {})
            summary["targets"][target] = {
                "vulnerabilities": stats.get('total_num_vulnerabilities', 0),
                "exploits": stats.get('total_num_exploits', 0),
                "ports_scanned": stats.get('num_scanned_ports', 0)
            }
        
        siaas_aux.write_to_local_file(report_path, summary)
        logger.info(f"Summary report exported to {report_path}")
    
    except Exception as e:
        logger.error(f"Failed to export summary report: {e}")


if __name__ == "__main__":
    
    log_level = logging.INFO
    logging.basicConfig(
        format='%(asctime)s %(levelname)-5s %(filename)s [%(threadName)s] %(message)s', 
        datefmt='%Y-%m-%d %H:%M:%S', 
        level=log_level
    )
    
    if os.geteuid() != 0:
        print("You need to be root to run this script!", file=sys.stderr)
        sys.exit(1)
    
    print("\n" + "="*60)
    print("ENHANCED Metasploit Scanner for SIAAS")
    print("="*60)
    print("\nAvailable scan modes:")
    print("  1. Full scan (all modules)")
    print("  2. Web application scan")
    print("  3. Service-specific scan")
    print("  4. Quick scan (basic modules only)")
    
    mode = input('\nSelect scan mode (1-4, default=1): ').strip()
    target = input('Enter target for Metasploit scan: ').strip()
    
    if target == "":
        target = "127.0.0.1"
    
    print('\n' + "="*60)
    print(f"Starting scan for {target}...")
    print("="*60 + '\n')
    
    # Adjust based on mode
    if mode == "2":
        # Web application focus
        port = input('Enter port (default=80): ').strip() or "80"
        logger.info(f"Web application scan mode for {target}:{port}")
        
        # Run web scan directly
        web_results, vulns, exploits = run_web_application_scan(target, port)
        
        print('\nWeb Application Scan Results:')
        print(f"  Target: {target}:{port}")
        print(f"  Vulnerabilities: {vulns}")
        print(f"  Exploits: {exploits}")
        
        if web_results:
            print("\nFindings:")
            for module, findings in web_results.items():
                if findings:
                    print(f"  {module}: {len(findings)} findings")
    
    elif mode == "3":
        # Service-specific
        service = input('Enter service to scan (http, ssh, smb, ftp, etc): ').strip().lower()
        port = input(f'Enter port for {service} (default based on service): ').strip()
        
        if not port:
            # Default ports
            defaults = {'http': '80', 'ssh': '22', 'smb': '445', 'ftp': '21', 'mysql': '3306'}
            port = defaults.get(service, '80')
        
        modules = get_recommended_modules_for_service(service, port)
        
        print(f"\nRunning {len(modules)} modules for {service} on port {port}...")
        
        total_vulns = 0
        total_exploits = 0
        
        for module_type, module_name, options in modules:
            print(f"  Running: {module_name}")
            results, n_vulns, n_exploits = scan_with_metasploit(target, module_type, module_name, options)
            total_vulns += n_vulns
            total_exploits += n_exploits
        
        print(f"\nService Scan Results for {service}:")
        print(f"  Vulnerabilities: {total_vulns}")
        print(f"  Exploits: {total_exploits}")
    
    else:
        # Full scan (mode 1 or 4)
        result = main(target)
        
        print('\n' + "="*60)
        print("ENHANCED Metasploit Scan Complete")
        print("="*60)
        print(f"\nTarget: {result[0]}")
        print(f"Ports scanned: {result[1]['stats']['num_scanned_ports']}")
        print(f"Vulnerabilities found: {result[1]['stats']['total_num_vulnerabilities']}")
        print(f"Exploits found: {result[1]['stats']['total_num_exploits']}")
        print(f"Time taken: {result[1]['stats']['time_taken_sec']}s")
        
        # Show summary of findings by severity
        if 'summary' in result[1]:
            summary = result[1]['summary']
            print(f"\nCritical findings: {summary.get('critical_findings', 0)}")
            print(f"High risk findings: {summary.get('high_risk_findings', 0)}")
        
        # List ports with findings
        print("\nPorts with findings:")
        for port, port_info in result[1].get('scanned_ports', {}).items():
            scan_results = port_info.get('scan_results', {})
            if scan_results:
                findings_count = sum(len(v) for v in scan_results.values())
                if findings_count > 0:
                    print(f"  {port}: {findings_count} findings")
    
    print('\nAll done. Bye!\n')
